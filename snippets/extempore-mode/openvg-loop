# -*- mode: snippet -*-
# name: openvg-loop
# key: vgloop
# --
(define width ${1:`(display-pixel-width)`.0})
(define height ${2:`(display-pixel-height)`.0})
(bind-val width double width)
(bind-val height double height)
(define fullscreen ${3:#t})

(define *vg-ctx* (gl:make-ctx ":0.0" fullscreen 0. 0. width height))

(sys:load "libs/xtm.xtm")
(sys:load "libs/external/shaders.xtm")
(sys:load "libs/external/openvg.xtm")

(xtm_render_setup (real->integer width) (real->integer height))
(let ((vg-ctx-res (xtm_vg_create_context (real->integer width)
                                         (real->integer height))))
  (if (<> vg-ctx-res 1) (xtm_vg_print_error)))

(bind-func vgframe:XTMRENDERCB
  (lambda (frame shader m v p data)
    (let ((path (xtm_create_vgpath))
          (stroke (vgCreatePaint))
          (fill (vgCreatePaint))
          (i:double 0.)
          (n:double 10.))
      (xtm_vg_reset_matrices)
      ;; (xtm_vg_clear 0. 0. 0. 1. (dtoi64 width) (dtoi64 height))
      (xtm_paint_setup_fill fill 1. 1. 1. 1.)
      (xtm_paint_setup_stroke stroke 1. 1. 1. 1. 10.)
      ;; create the path
      $0
      ;; (xtm_draw_path path)
      ;; cleanup
      (xtm_destroy_paint fill)
      (xtm_destroy_paint stroke)
      (xtm_vg_print_error))
    void))

(bind-func gl_render
  (lambda ()
    ;;          pre  opaq trans post    data
    (xtm_render null null null  vgframe null)
    void))

(define gl-loop
  (lambda (time delta-t$9)
    (gl_render)
    (gl:swap-buffers *vg-ctx*)
    (callback (+ time (* *second* delta-t) 0.9)
              'gl-loop
              (+ time (* *second* delta-t))
              delta-t$9)))

(gl-loop (*metro* (*metro* 'get-beat 4)) 1/${10:30})